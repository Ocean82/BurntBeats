import Stripe from 'stripe';
import { WebhookEventLogger } from './webhookLogger';
import { EventQueue } from '../queues/eventQueue';
import { RetryPolicy } from '../types';

interface WebhookEventProcessorConfig {
  stripe: Stripe;
  logger: WebhookEventLogger;
  retryPolicy: RetryPolicy;
}

export class WebhookEventProcessor {
  private stripe: Stripe;
  private logger: WebhookEventLogger;
  private queue: EventQueue;
  private retryPolicy: RetryPolicy;

  constructor(config: WebhookEventProcessorConfig) {
    this.stripe = config.stripe;
    this.logger = config.logger;
    this.retryPolicy = config.retryPolicy;
    this.queue = new EventQueue({
      concurrency: 5,
      logger: this.logger,
    });
  }

  async processWithRetry(event: Stripe.Event): Promise<void> {
    try {
      await this.queue.add(async () => {
        await this.processEventWithRetryLogic(event);
      });
    } catch (error) {
      this.logger.logError({
        error: error as Error,
        context: {
          eventId: event.id,
          type: 'queue_error',
        },
      });
      throw error;
    }
  }

  private async processEventWithRetryLogic(
    event: Stripe.Event,
    attempt = 1
  ): Promise<void> {
    try {
      await this.processEvent(event);
    } catch (error) {
      if (attempt >= this.retryPolicy.maxRetries) {
        throw error;
      }

      const delay = this.retryPolicy.delayMs * attempt;
      this.logger.logRetryAttempt({
        eventId: event.id,
        attempt,
        maxAttempts: this.retryPolicy.maxRetries,
        delay,
        error: error as Error,
      });

      await new Promise(resolve => setTimeout(resolve, delay));
      return this.processEventWithRetryLogic(event, attempt + 1);
    }
  }

  private async processEvent(event: Stripe.Event): Promise<void> {
    try {
      this.logger.logProcessingStart(event.id);

      // Implement your business logic here
      switch (event.type) {
        case 'payment_intent.succeeded':
          await this.handlePaymentIntentSucceeded(event);
          break;
        case 'payment_intent.payment_failed':
          await this.handlePaymentIntentFailed(event);
          break;
        case 'charge.refunded':
          await this.handleChargeRefunded(event);
          break;
        default:
          this.logger.logUnhandledEvent(event);
      }

      this.logger.logProcessingComplete(event.id);
    } catch (error) {
      this.logger.logProcessingError({
        eventId: event.id,
        error: error as Error,
      });
      throw error;
    }
  }

  private async handlePaymentIntentSucceeded(event: Stripe.Event): Promise<void> {
    const paymentIntent = event.data.object as Stripe.PaymentIntent;
    // Implementation details
  }

  private async handlePaymentIntentFailed(event: Stripe.Event): Promise<void> {
    const paymentIntent = event.data.object as Stripe.PaymentIntent;
    // Implementation details
  }

  private async handleChargeRefunded(event: Stripe.Event): Promise<void> {
    const charge = event.data.object as Stripe.Charge;
    // Implementation details
  }
}
